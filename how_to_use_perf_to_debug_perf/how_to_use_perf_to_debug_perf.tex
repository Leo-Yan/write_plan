%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Using Diaz essay LaTeX template from:
% http://www.LaTeXTemplates.com
%
% Authors:
% Vel (vel@LaTeXTemplates.com)
% Nicolas Diaz (nsdiaz@uc.cl)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
\documentclass[11pt]{diazessay} % Font size (can be 10pt, 11pt or 12pt)

\usepackage{listings}
\usepackage{tikz}
\usepackage{hyperref}
\usetikzlibrary{positioning}
\usetikzlibrary{arrows}

\lstset{frame=tb,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle=\fontsize{8}{9}\selectfont\ttfamily,
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{black},
  %stringstyle=\color{mauve},
  breaklines=false,
  breakatwhitespace=false,
  tabsize=3
}

% Defines a `datastore' shape for use in DFDs.  This inherits from a
% rectangle and only draws two horizontal lines.
\makeatletter
\pgfdeclareshape{datastore}{
  \inheritsavedanchors[from=rectangle]
  \inheritanchorborder[from=rectangle]
  \inheritanchor[from=rectangle]{center}
  \inheritanchor[from=rectangle]{base}
  \inheritanchor[from=rectangle]{north}
  \inheritanchor[from=rectangle]{north east}
  \inheritanchor[from=rectangle]{east}
  \inheritanchor[from=rectangle]{south east}
  \inheritanchor[from=rectangle]{south}
  \inheritanchor[from=rectangle]{south west}
  \inheritanchor[from=rectangle]{west}
  \inheritanchor[from=rectangle]{north west}
  \backgroundpath{
    %  store lower right in xa/ya and upper right in xb/yb
    \southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
    \northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y
    \pgfpathmoveto{\pgfpoint{\pgf@xa}{\pgf@ya}}
    \pgfpathlineto{\pgfpoint{\pgf@xb}{\pgf@ya}}
    \pgfpathmoveto{\pgfpoint{\pgf@xa}{\pgf@yb}}
    \pgfpathlineto{\pgfpoint{\pgf@xb}{\pgf@yb}}
 }
}
\makeatother

% TITLE SECTION
\title{\textbf{How to Use Perf to Debug Perf}}
\author{\textbf{Leo Yan} \textit{<leo.yan@linaro.org>}} % Author and institution
\date{\today} % Date, use \date{} for no date

\def\code#1{\texttt{#1}}

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Print the title section

% ABSTRACT AND KEYWORDS

\begin{abstract}
Debugging is for inspecting a program, for both user space and kernel space.
The perf tool contains complex logic for exchanging data through system calls,
making it a common practice to debug perf in everyday.

This article explores various debugging techniques, organized from simple to
complex, with using the perf tool as the target program. As it explores these
debugging methods, the attention is directed towards the perf as debugging
tool. At last, the article explains how to use perf to debug perf.
\end{abstract}

\hspace*{3.6mm}\textit{Keywords: Linux, debug, ftrace, kprobe, uprobe, perf } % Keywords
\vspace{30pt} % Vertical whitespace between the abstract and first section

% ESSAY BODY

\section*{Introduction}

First of all, this article has no plan to address traditional debuggers, e.g.
GDB or JTAG based debuggers. These tools use stop-the-world method to debug
programs: it firstly stops a target program, then it takes chance to check
the context for the program. The \textit{context} can be a software concept,
e.g. a thread or task context, a debugger can read variables from the task's
stack or heap. The \textit{context} can be a hardware context as well - when
a developer is using JTAG debugger to connect hardware and stop CPU, the
hardware registers and memory can be reviewed.

The purpose of this documentation is to discuss tools which can provide
tracing capability in runtime. The trace data, including events and variable
values, are gathered in certain format without pausing the program for
debugging. The content will be divided into four sections:
\begin{itemize}
	\item Printing;
	\item Debugging with ftrace;
	\item Dynamic tracing;
	\item Using perf for debugging.
\end{itemize}

\section*{Printing}

Usually, a beginner studying C programming learns the first code piece is for
printing the string 'hello world!'.

\begin{lstlisting}
#include <stdio.h>
int main(void)
{
        printf("Hello world!\n");
        return 0;
}
\end{lstlisting}

The above code implicitly introduces a handy tracing tool: libc's
\code{printf()}. Then, when starting to access the Linux kernel, its
equivalent function \code{printk()} will no longer be strange.

A printing log means an event has occurred, alongside variables can be printed
out - this is perfect to act as tracing.

The printing is reliable in most cases. \code{printk()} is a context safe API
- even if a developer has no knowledge for interrupt context, thread context
and bottom-half context (e.g. in softirq or tasklet), printing still can work
as a main debugging method.

On the other hand, developers need to tolerate cons introduced by printing.
If logs are output into the UART console, developers suffer performance
penalty caused by the low speed of the UART port. In a worse case, the
printing can alter program flow and might lead to the timing issues hardly to
be reproduced.

It becomes challenging for using printing to debug a program which crosses
both user space and kernel space. The reason is \code{printf()} and
\code{printk()} store logs in separate buffers, resulting in logs that are not
easily readable due to out-of-order output.

To resolve this issue, syslog is suggested. A program needs to use
\code{syslog()} to replace \code{printf()} for routing logs to syslog
service, all modules supporting syslog in system can output logs into a
central place. But syslog is not necessarily deployed in a system, and many
programs, including the perf, don't support syslog at all. As syslog may not
be pluasible in some situations, we need to explore other debugging measures.

\subsection*{Debugging with ftrace}

If we are looking for a better debugging tool with lower performance penalties
and support for tracing in both user space and kernel space, ftrace appears as
a promising candidate.

Firstly, ftrace uses a ring buffer to store trace data, allowing users to save
the trace data into a file for testing and then perform post-analysis. This
approach enables ftrace to avoid the tracing latency caused by console, unlike
printing.

Secondly, ftrace supports both kernel and user space tracing. The entire trace
data is recorded in a single file and displayed in a time-ordered format, thus
the output result is friendly for review.

\subsubsection*{Printing in ftrace}

Printing is supported in ftrace.

In the kernel, \code{trace\_printk()} is used to output logs into the ftrace
ring buffer. Once you use it, you will find this API quite useful: logs saved
in ftrace buffer will not be bothered by console's long latency, and by
enlarging buffer size, you will have sufficient capacity to store extensive
logs. These logs will not flood the console immediately, you can extract logs
into file whenever you want to parse them.

A sysfs node called \code{trace\_marker} that allows the user space to place
logs into ftrace buffer. Through this interface, user space events and kernel
events can be synchronized together, thus developers can understand a flow
spanning the two spaces. The kernel documentation
\code{Documentation/trace/ftrace.rst} gives an example for how to write a log
into the \code{trace\_marker} node in C code. The code below is slightly
tweaked for easier calling.

\begin{lstlisting}
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

static void trace_write(const char *fmt, ...)
{
        va_list ap;
        char buf[256];
        int trace_fd, n;

        trace_fd = open("/sys/kernel/debug/tracing/trace_marker",
                          O_WRONLY);
        if (trace_fd < 0)
                return;

        va_start(ap, fmt);
        n = vsnprintf(buf, 256, fmt, ap);
        va_end(ap);

        write(trace_fd, buf, n);
}
\end{lstlisting}

A typical use case for \code{trace\_marker} is found in
\href{https://perfetto.dev/docs/data-sources/atrace}{ATrace}, which is a
part of Google's \href{https://ui.perfetto.dev/}{Perfetto} tool. Perfetto
is widely used for profiling Android UI performance and depends on the
ATrace to trace application events - the \code{trace\_marker} is the
underlying mechanism for tracing. While this article will remain on
basic tools, it will not dive into ATrace's details.

\subsubsection*{Debugging perf with ftrace}

Now it's a good time point for us to apply ftrace for debugging.

The following experiment is to inspect how the AUX buffer is consumed in perf.
The AUX buffer is a ring buffer designed to store hardware trace data from
components such as Arm CoreSight, Intel PT, etc.

After the trace data has been filled by a hardware IP, the kernel calls the
\code{perf\_aux\_output\_end()} function to update the head of the buffer and
send a notification to user space.

In the code piece below, the buffer supports two modes: overwrite mode and
normal mode. The overwrite mode is used for snapshots. For simplicity in
explanation, we solely focus on the normal mode from line 493 to line 498.
Line 496 saves the old head value into the \code{aux\_head} variable; in line
497, \code{rb->aux\_head} is updated as a new head by adding the \code{size}
to the old head.

We add tracing code in lines 500 and 501 to print the old head, the new head
and the size into ftrace.

\begin{lstlisting}
481 void perf_aux_output_end(struct perf_output_handle *handle, unsigned long size)
482 {
483         bool wakeup = !!(handle->aux_flags & PERF_AUX_FLAG_TRUNCATED);
484         struct perf_buffer *rb = handle->rb;
485         unsigned long aux_head;
486 
487         /* in overwrite mode, driver provides aux_head via handle */
488         if (rb->aux_overwrite) {
489                 handle->aux_flags |= PERF_AUX_FLAG_OVERWRITE;
490 
491                 aux_head = handle->head;
492                 rb->aux_head = aux_head;
493         } else {
494                 handle->aux_flags &= ~PERF_AUX_FLAG_OVERWRITE;
495 
496                 aux_head = rb->aux_head;
497                 rb->aux_head += size;
498         }
499 
500         trace_printk("old_head=0x%lx new_head=0x%lx size=0x%lx\n",
501                      aux_head, rb->aux_head, size);
            ...
535 }
\end{lstlisting}

The perf tool in user space calls \code{auxtrace\_mmap\_\_read\_head()} to
retrieve the latest head of the buffer. As shown from lines 1869 to 1875 in
the below code, it handles the overflow case by using a mask or dividing by
the buffer length. Finally, a delta between the old head and the new head is
calculated, taking into account any wrapping around, which is accomplished
between line 1877 and line 1880.

It already contains debugging code at line 1866 for printing logs, but it
only outputs messages to a terminal or a log file, we have no chance to print
them with kernel logs together.  This is why the \code{trace\_write()}
function at line 1882 is added to write logs into the ftrace buffer via the
\code{trace\_maker} interface.

\begin{lstlisting}
1844 static int __auxtrace_mmap__read(struct mmap *map,
1845                                  struct auxtrace_record *itr,
1846                                  struct perf_tool *tool, process_auxtrace_t fn,
1847                                  bool snapshot, size_t snapshot_size)
1848 {
1849         struct auxtrace_mmap *mm = &map->auxtrace_mmap;
1850         u64 head, old = mm->prev, offset, ref;
1851         unsigned char *data = mm->base;
1852         size_t size, head_off, old_off, len1, len2, padding;
1853         union perf_event ev;
1854         void *data1, *data2;
1855         int kernel_is_64_bit = perf_env__kernel_is_64_bit(evsel__env(NULL));
1856
1857         head = auxtrace_mmap__read_head(mm, kernel_is_64_bit);
1858
1859         if (snapshot &&
1860             auxtrace_record__find_snapshot(itr, mm->idx, mm, data, &head, &old))
1861                 return -1;
1862
1863         if (old == head)
1864                 return 0;
1865
1866         pr_debug3("auxtrace idx %d old %#"PRIx64" head %#"PRIx64" diff %#"PRIx64"\n",
1867                   mm->idx, old, head, head - old);
1868
1869         if (mm->mask) {
1870                 head_off = head & mm->mask;
1871                 old_off = old & mm->mask;
1872         } else {
1873                 head_off = head % mm->len;
1874                 old_off = old % mm->len;
1875         }
1876
1877         if (head_off > old_off)
1878                 size = head_off - old_off;
1879         else
1880                 size = mm->len - (old_off - head_off);
1881
1882         trace_write("%s: old_offset=0x%lx head_offset=0x%lx size=0x%lx\n",
1883                     __func__, old_off, head_off, size);
            ...
1957 }
\end{lstlisting}

Rebuild the Linux kernel and perf with the added printing code, reboot the
system, then it will be ready for debugging.

To prepare a fresh context for ftrace before running the test, you can use
several commands:

\begin{lstlisting}[
  	language=sh,
	breaklines=true
]
# Stop tracing
echo 0 > /sys/kernel/debug/tracing/tracing_on

# Cleanup ftrace data
echo > /sys/kernel/debug/tracing/trace

# Start tracing
echo 1 > /sys/kernel/debug/tracing/tracing_on
\end{lstlisting}

Then, run the test and stop tracing:

\begin{lstlisting}
# Run test
perf record -e cs_etm// -- ls

# Stop tracing
echo 0 > /sys/kernel/debug/tracing/tracing_on
\end{lstlisting}

At last, you can dump tracing log:

\begin{lstlisting}[
  	language=sh,
	breaklines=true
]
# Dump tracing data
cat /sys/kernel/debug/tracing/trace

# tracer: nop
#
# entries-in-buffer/entries-written: 7/7   #P:6
#
#                                _-----=> irqs-off/BH-disabled
#                               / _----=> need-resched
#                              | / _---=> hardirq/softirq
#                              || / _--=> preempt-depth
#                              ||| / _-=> migrate-disable
#                              |||| /     delay
#           TASK-PID     CPU#  |||||  TIMESTAMP  FUNCTION
#              | |         |   |||||     |         |
              ls-2041    [003] d..3.   220.497444: perf_aux_output_end: old_head=0x0 new_head=0xe26a0 size=0xe26a0
              ls-2041    [003] d..3.   220.498274: perf_aux_output_end: old_head=0xe26a0 new_head=0xf0da0 size=0xe700
              ls-2041    [003] d..3.   220.500091: perf_aux_output_end: old_head=0xf0da0 new_head=0xf61a0 size=0x5400
              ls-2041    [003] d..3.   220.500743: perf_aux_output_end: old_head=0xf61a0 new_head=0x108080 size=0x11ee0
              ls-2041    [003] d..3.   220.502813: perf_aux_output_end: old_head=0x108080 new_head=0x119dd0 size=0x11d50
              ls-2041    [003] d..1.   220.508788: perf_aux_output_end: old_head=0x119dd0 new_head=0x1d5310 size=0xbb540
            perf-2040    [002] .....   220.508985: tracing_mark_write: __auxtrace_mmap__read: old_offset=0x0 head_offset=0x1d5310 size=0x1d5310
\end{lstlisting}

The logs show that the \code{perf\_aux\_output\_end()} function has been
invoked multiple times in the kernel. The perf tool called
\code{\_\_auxtrace\_mmap\_\_read()} once to read out all trace data from the AUX
buffer. The writing to the AUX buffer in the kernel and the reading in user
space are not paired. It's apparent that the perf tool is not necessarily woken
up every time the kernel stores trace data. Nonetheless, we still don't
know the scheduling within this flow, which will be discussed soon.

\subsubsection*{Tracepoints in ftrace}

The naming 'ftrace' is derived from 'function trace', users can enable
function tracer or function graph tracer for function-based tracing. Over time,
ftrace has extended to support latency tracer for profiling scheduling latency.
In the log above, \code{"tracer:\ nop"} indicates that no tracer is enabled.

Furthermore, ftrace provides tracepoints which are predefined and invoked in
the kernel. These are commonly known as "static tracepoints". After
the system boots up, you can see the available tracepoints in the subfolder
\code{events} under the ftrace's debugfs folder.

More importantly, ftrace can combine printing, tracers, and tracepoints
together for debugging. The previous section was absent to show how the perf
tool is waken up in the test, the scheduler tracepoints can help us to easily
understand scheduling behaviours. By enabling the tracepoints, we get logs:

\begin{lstlisting}[
  	language=sh,
	breaklines=true
]
# Enable scheduler tracepoints
echo 1 > /sys/kernel/debug/tracing/events/sched/enable

# Run test
perf record -e cs_etm// -- ls

# Stop tracing
echo 0 > /sys/kernel/debug/tracing/tracing_on

# Dump tracing data
cat /sys/kernel/debug/tracing/trace

#                                _-----=> irqs-off/BH-disabled
#                               / _----=> need-resched
#                              | / _---=> hardirq/softirq
#                              || / _--=> preempt-depth
#                              ||| / _-=> migrate-disable
#                              |||| /     delay
#           TASK-PID     CPU#  |||||  TIMESTAMP  FUNCTION
#              | |         |   |||||     |         |
...
              ls-2660    [003] d..1.  4755.179918: perf_aux_output_end: old_head=0x11c460 new_head=0x21d7a0 size=0x101340
              ls-2660    [003] d.h4.  4755.179979: sched_waking: comm=perf pid=2659 prio=120 target_cpu=001
          <idle>-0       [001] dNh2.  4755.179998: sched_wakeup: comm=perf pid=2659 prio=120 target_cpu=001
          <idle>-0       [001] d..2.  4755.180002: sched_switch: prev_comm=swapper/1 prev_pid=0 prev_prio=120 prev_state=R ==> next_comm=perf next_pid=2659 next_prio=120
              ls-2660    [003] d.h2.  4755.180014: sched_stat_runtime: comm=ls pid=2660 runtime=4493620 [ns]
            perf-2659    [001] .....  4755.180089: tracing_mark_write: __auxtrace_mmap__read: old_offset=0x0 head_offset=0x21d7a0 size=0x21d7a0
\end{lstlisting}

The logs show that the profiled program \(ls\) stored hardware tracing data
into AUX buffer. Then it woke up the perf tool in the \code{sched\_waking}
event. Afterwards, the \(CPU1\) was pulled out from idle, and the scheduler
placed the perf to run on it. We can know that the \(ls\) program and the
perf running on two different CPUs, so that avoid performance degradation
due to parallel execution during profiling.

In this section, the printing and static tracepoints in ftrace have shown
their power. However, they are not efficient, as we must rebuild the source
code to add tracing. We will explore dynamic tracing to add tracepoints on the
fly.

\section*{Dynamic tracing}

If you have experience with debugger, an often used feature is breakpoint. You
select a code line, set a breakpoint, and then kick off the program to run.
When the program reaches the breakpoint, it halts, and the debugger takes
over control. At this point, since the program is stopped, you can take your
time to read variables, review memory content, and dump CPU general registers.

A subtle aspect of a breakpoint is it can be set as either a hardware
breakpoint or a software breakpoint. A hardware breakpoint is to set an
address in the CPU's debug register, while a software breakpoint uses the
break instruction (the Arm instruction is \code{BRK}) to replace an
original instruction at the specified address. Both methods ultimately
interrupt the program execution and transfer control to the debugger for
further inspection.

We can take dynamic tracing as a self-hosted debugger, often referred to as
\(probe\) in Linux. When we add a probe, a break instruction is injected into
a specified address, and an event is attached to it for accessing additional
data. The original instruction is copied to somewhere for single-step
execution.

Ftrace provides \(kprobe\) and \(uprobe\) for adding probe in the kernel and
user space respectively. We will see demonstrations of how to use them.

\subsubsection*{Adding probe in the kernel}

\subsubsection*{Adding probe in user space}

\begin{lstlisting}[
  	language=sh,
	breaklines=true
]
cd /sys/kernel/debug/tracing/
echo 'p:myprobe 0xffff8000802a100c new_head=%x0:x64 \
       old_head=%x1:x64 size=%x2:x64' > kprobe_events
echo 'p:myprobe perf_aux_output_end+0x12c new_head=%x0:x64 \
       old_head=%x1:x64 size=%x2:x64' > kprobe_events
echo 'p:myprobe perf_aux_output_end+0x12c new_head=%x0:x64 \
       old_head=+144(%x20):x64 size=%x2:x64' > kprobe_events

echo 1 > events/kprobes/myprobe1/enable

echo 'p /mnt/linux-kernel/linux-cs-dev/tools/perf/perf:0x2079e0 old_off=+128(%sp):x64 head_off=+120(%sp):x64 size=+112(%sp):x64' > uprobe_events

echo 1 > events/uprobes/p_perf_0x2079e0/enable

cat trace
# tracer: nop
#
# entries-in-buffer/entries-written: 7/7   #P:6
#
#                                _-----=> irqs-off/BH-disabled
#                               / _----=> need-resched
#                              | / _---=> hardirq/softirq
#                              || / _--=> preempt-depth
#                              ||| / _-=> migrate-disable
#                              |||| /     delay
#           TASK-PID     CPU#  |||||  TIMESTAMP  FUNCTION
#              | |         |   |||||     |         |
              ls-3480    [005] d..3. 13312.444215: myprobe1: (perf_aux_output_end+0x12c/0x138) new_head=0xd71f0 old_head=0x0 size=0xd71f0
              ls-3480    [005] d..3. 13312.444779: myprobe1: (perf_aux_output_end+0x12c/0x138) new_head=0xe22a0 old_head=0xd71f0 size=0xb0b0
              ls-3480    [005] d..3. 13312.446907: myprobe1: (perf_aux_output_end+0x12c/0x138) new_head=0xf2950 old_head=0xe22a0 size=0x106b0
              ls-3480    [005] d..3. 13312.449854: myprobe1: (perf_aux_output_end+0x12c/0x138) new_head=0x10e470 old_head=0xf2950 size=0x1bb20
              ls-3480    [005] d..3. 13312.456476: myprobe1: (perf_aux_output_end+0x12c/0x138) new_head=0x1ac6e0 old_head=0x10e470 size=0x9e270
              ls-3480    [005] d..1. 13312.460459: myprobe1: (perf_aux_output_end+0x12c/0x138) new_head=0x243560 old_head=0x1ac6e0 size=0x96e80
            perf-3479    [002] DNZff 13312.460598: p_perf_0x2079e0: (0xaaaad0f979e0) old_off=0x0 head_off=0x243560 size=0x243560
\end{lstlisting}


\end{document}
