%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Using Diaz essay LaTeX template from:
% http://www.LaTeXTemplates.com
%
% Authors:
% Vel (vel@LaTeXTemplates.com)
% Nicolas Diaz (nsdiaz@uc.cl)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
\documentclass[11pt]{diazessay} % Font size (can be 10pt, 11pt or 12pt)

\usepackage{listings}
\usepackage{tikz}
\usepackage{hyperref}
\usetikzlibrary{positioning}
\usetikzlibrary{arrows}

\lstset{frame=tb,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{black},
  %stringstyle=\color{mauve},
  breaklines=false,
  breakatwhitespace=false,
  tabsize=3
}

% Defines a `datastore' shape for use in DFDs.  This inherits from a
% rectangle and only draws two horizontal lines.
\makeatletter
\pgfdeclareshape{datastore}{
  \inheritsavedanchors[from=rectangle]
  \inheritanchorborder[from=rectangle]
  \inheritanchor[from=rectangle]{center}
  \inheritanchor[from=rectangle]{base}
  \inheritanchor[from=rectangle]{north}
  \inheritanchor[from=rectangle]{north east}
  \inheritanchor[from=rectangle]{east}
  \inheritanchor[from=rectangle]{south east}
  \inheritanchor[from=rectangle]{south}
  \inheritanchor[from=rectangle]{south west}
  \inheritanchor[from=rectangle]{west}
  \inheritanchor[from=rectangle]{north west}
  \backgroundpath{
    %  store lower right in xa/ya and upper right in xb/yb
    \southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
    \northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y
    \pgfpathmoveto{\pgfpoint{\pgf@xa}{\pgf@ya}}
    \pgfpathlineto{\pgfpoint{\pgf@xb}{\pgf@ya}}
    \pgfpathmoveto{\pgfpoint{\pgf@xa}{\pgf@yb}}
    \pgfpathlineto{\pgfpoint{\pgf@xb}{\pgf@yb}}
 }
}
\makeatother

% TITLE SECTION
\title{\textbf{How to Use Perf to Debug Perf}}
\author{\textbf{Leo Yan} \textit{<leo.yan@linaro.org>}} % Author and institution
\date{\today} % Date, use \date{} for no date

\def\code#1{\texttt{#1}}

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Print the title section

% ABSTRACT AND KEYWORDS

\begin{abstract}
Debugging is for inspecting a program, for both user space and kernel space.
The perf tool contains complex logic for exchanging data through system calls,
making it a common practice to debug perf in everyday.

This article explores various debugging techniques, organized from simple to
complex, with using the perf tool as the target program. As it explores these
debugging methods, the attention is directed towards the perf as debugging
tool. At last, the article explains how to use perf to debug perf.
\end{abstract}

\hspace*{3.6mm}\textit{Keywords: Linux, debug, ftrace, kprobe, uprobe, perf } % Keywords
\vspace{30pt} % Vertical whitespace between the abstract and first section

% ESSAY BODY

\section*{Introduction}

First of all, this article has no plan to address traditional debuggers, e.g.
GDB or JTAG based debuggers. These tools use stop-the-world method to debug
programs: it firstly stops a target program, then it takes chance to check
the context for the program. The \textit{context} can be a software concept,
e.g. a thread or task context, a debugger can read variables from the task's
stack or heap. The \textit{context} can be a hardware context as well - when
a developer is using JTAG debugger to connect hardware and stop CPU, the
hardware registers and memory can be reviewed.

The purpose of this documentation is to discuss tools which can provide
tracing capability in runtime. The trace data, including events and variable
values, are gathered in certain format without pausing the program for
debugging. The content will be divided into four sections:
\begin{itemize}
	\item Printing;
	\item Debugging with ftrace;
	\item Dynamic tracing;
	\item Using perf for debugging.
\end{itemize}

\section*{Printing}

Usually, a beginner studying C programming learns the first code piece is for
printing the string 'hello world!'.

\begin{lstlisting}
#include <stdio.h>
int main(void)
{
        printf("Hello world!\n");
        return 0;
}
\end{lstlisting}

The above code implicitly introduces a handy tracing tool: libc's
\code{printf()}. Then, when starting to access the Linux kernel, its
equivalent function \code{printk()} will no longer be strange.

A printing log means an event has occurred, alongside variables can be printed
out - this is perfect to act as tracing.

The printing is reliable in most cases. \code{printk()} is a context safe API
- even if a developer has no knowledge for interrupt context, thread context
and bottom-half context (e.g. in softirq or tasklet), printing still can work
as a main debugging method.

On the other hand, developers need to tolerate cons introduced by printing.
If logs are output into the UART console, developers suffer performance
penalty caused by the low speed of the UART port. In a worse case, the
printing can alter program flow and might lead to the timing issues hardly to
be reproduced.

It becomes challenging for using printing to debug a program which crosses
both user space and kernel space. The reason is \code{printf()} and
\code{printk()} store logs in separate buffers, resulting in logs that are not
easily readable due to out-of-order output.

To resolve this issue, syslog is suggested. A program needs to use
\code{syslog()} to replace \code{printf()} for routing logs to syslog
service, all modules supporting syslog in system can output logs into a
central place. But syslog is not necessarily deployed in a system, and many
programs, including the perf, don't support syslog at all. As syslog may not
be pluasible in some situations, we need to explore other debugging measures.

\subsection*{Debugging with ftrace}

If we are looking for a better debugging tool with lower performance penalties
and support for tracing in both user space and kernel space, ftrace appears as
a promising candidate.

Firstly, ftrace uses a ring buffer to store trace data, allowing users to save
the trace data into a file for testing and then perform post-analysis. This
approach enables ftrace to avoid the tracing latency caused by console, unlike
printing.

Secondly, ftrace supports both kernel and user space tracing. The entire trace
data is recorded in a single file and displayed in a time-ordered format, thus
the output result is friendly for review.

\subsubsection*{Printing in ftrace}

Printing is supported in ftrace.

In the kernel, \code{trace\_printk()} is used to output logs into the ftrace
ring buffer. Once you use it, you will find this API quite useful: logs saved
in ftrace buffer will not be bothered by console's long latency, and by
enlarging buffer size, you will have sufficient capacity to store extensive
logs. These logs will not flood the console immediately, you can extract logs
into file whenever you want to parse them.

A sysfs node called \code{trace\_marker} that allows the user space to place
logs into ftrace buffer. Through this interface, user space events and kernel
events can be synchronized together, thus developers can understand a flow
spanning the two spaces. The kernel documentation
\code{Documentation/trace/ftrace.rst} gives an example for how to write a log
into the \code{trace\_marker} node in C code:

\begin{lstlisting}
trace_fd = open("trace_marker", O_WRONLY);

void trace_write(const char *fmt, ...)
{
        va_list ap;
        char buf[256];
        int n;

        if (trace_fd < 0)
                return;

        va_start(ap, fmt);
        n = vsnprintf(buf, 256, fmt, ap);
        va_end(ap);

        write(trace_fd, buf, n);
}
\end{lstlisting}

A typical use case for \code{trace\_marker} is found in
\href{https://perfetto.dev/docs/data-sources/atrace}{ATrace}, which is a
part of Google's \href{https://ui.perfetto.dev/}{Perfetto} tool. Perfetto
is widely used for profiling Android UI performance and depends on the
ATrace to trace application events - the \code{trace\_marker} is the
underlying mechanism for tracing. While this article will remain on
basic tools, it will not dive into ATrace's details.

\subsubsection*{Debugging perf with ftrace}

After a rough introduction for printing in ftrace, now it's a good time point
to apply it to debug perf.

\end{document}
