%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Using Diaz essay LaTeX template from:
% http://www.LaTeXTemplates.com
%
% Authors:
% Vel (vel@LaTeXTemplates.com)
% Nicolas Diaz (nsdiaz@uc.cl)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
\documentclass[11pt]{diazessay} % Font size (can be 10pt, 11pt or 12pt)

\usepackage{listings}
\usepackage{tikz}
\usepackage{hyperref}
\usetikzlibrary{positioning}
\usetikzlibrary{arrows}

\lstset{frame=tb,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle=\fontsize{8}{9}\selectfont\ttfamily,
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{black},
  %stringstyle=\color{mauve},
  breaklines=false,
  breakatwhitespace=false,
  tabsize=3
}

% Defines a `datastore' shape for use in DFDs.  This inherits from a
% rectangle and only draws two horizontal lines.
\makeatletter
\pgfdeclareshape{datastore}{
  \inheritsavedanchors[from=rectangle]
  \inheritanchorborder[from=rectangle]
  \inheritanchor[from=rectangle]{center}
  \inheritanchor[from=rectangle]{base}
  \inheritanchor[from=rectangle]{north}
  \inheritanchor[from=rectangle]{north east}
  \inheritanchor[from=rectangle]{east}
  \inheritanchor[from=rectangle]{south east}
  \inheritanchor[from=rectangle]{south}
  \inheritanchor[from=rectangle]{south west}
  \inheritanchor[from=rectangle]{west}
  \inheritanchor[from=rectangle]{north west}
  \backgroundpath{
    %  store lower right in xa/ya and upper right in xb/yb
    \southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
    \northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y
    \pgfpathmoveto{\pgfpoint{\pgf@xa}{\pgf@ya}}
    \pgfpathlineto{\pgfpoint{\pgf@xb}{\pgf@ya}}
    \pgfpathmoveto{\pgfpoint{\pgf@xa}{\pgf@yb}}
    \pgfpathlineto{\pgfpoint{\pgf@xb}{\pgf@yb}}
 }
}
\makeatother

% TITLE SECTION
\title{\textbf{How to Use Perf to Debug Perf}}
\author{\textbf{Leo Yan} \textit{<leo.yan@linaro.org>}} % Author and institution
\date{\today} % Date, use \date{} for no date

\def\code#1{\texttt{#1}}

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Print the title section

% ABSTRACT AND KEYWORDS

\begin{abstract}
Debugging is for inspecting a program, for both user space and kernel space.
The perf tool contains complex logic for exchanging data through system calls,
making it a common practice to debug perf in everyday.

This article explores various debugging techniques, organized from simple to
complex, with using the perf tool as the target program. As it explores these
debugging methods, the attention is directed towards the perf as debugging
tool. At last, the article explains how to use perf to debug perf.
\end{abstract}

\hspace*{3.6mm}\textit{Keywords: Linux, debug, ftrace, kprobe, uprobe, perf } % Keywords
\vspace{30pt} % Vertical whitespace between the abstract and first section

% ESSAY BODY

\section*{Introduction}

First of all, this article has no plan to address traditional debuggers, e.g.
GDB or JTAG based debuggers. These tools use stop-the-world method to debug
programs: it firstly stops a target program, then it takes chance to check
the context for the program. The \textit{context} can be a software concept,
e.g. a thread or task context, a debugger can read variables from the task's
stack or heap. The \textit{context} can be a hardware context as well - when
a developer is using JTAG debugger to connect hardware and stop CPU, the
hardware registers and memory can be reviewed.

The purpose of this documentation is to discuss tools which can provide
tracing capability in runtime. The trace data, including events and variable
values, are gathered in certain format without pausing the program for
debugging. The content will be divided into four sections:
\begin{itemize}
	\item Printing;
	\item Debugging with ftrace;
	\item Dynamic tracing;
	\item Using perf for debugging.
\end{itemize}

\section*{Printing}

Usually, a beginner studying C programming learns the first code piece is for
printing the string 'hello world!'.

\begin{lstlisting}
#include <stdio.h>
int main(void)
{
        printf("Hello world!\n");
        return 0;
}
\end{lstlisting}

The above code implicitly introduces a handy tracing tool: libc's
\code{printf()}. Then, when starting to access the Linux kernel, its
equivalent function \code{printk()} will no longer be strange.

A printing log means an event has occurred, alongside variables can be printed
out - this is perfect to act as tracing.

The printing is reliable in most cases. \code{printk()} is a context safe API
- even if a developer has no knowledge for interrupt context, thread context
and bottom-half context (e.g. in softirq or tasklet), printing still can work
as a main debugging method.

On the other hand, developers need to tolerate cons introduced by printing.
If logs are output into the UART console, developers suffer performance
penalty caused by the low speed of the UART port. In a worse case, the
printing can alter program flow and might lead to the timing issues hardly to
be reproduced.

It becomes challenging for using printing to debug a program which crosses
both user space and kernel space. The reason is \code{printf()} and
\code{printk()} store logs in separate buffers, resulting in logs that are not
easily readable due to out-of-order output.

To resolve this issue, syslog is suggested. A program needs to use
\code{syslog()} to replace \code{printf()} for routing logs to syslog
service, all modules supporting syslog in system can output logs into a
central place. But syslog is not necessarily deployed in a system, and many
programs, including the perf, don't support syslog at all. As syslog may not
be pluasible in some situations, we need to explore other debugging measures.

\subsection*{Debugging with ftrace}

If we are looking for a better debugging tool with lower performance penalties
and support for tracing in both user space and kernel space, ftrace appears as
a promising candidate.

Firstly, ftrace uses a ring buffer to store trace data, allowing users to save
the trace data into a file for testing and then perform post-analysis. This
approach enables ftrace to avoid the tracing latency caused by console, unlike
printing.

Secondly, ftrace supports both kernel and user space tracing. The entire trace
data is recorded in a single file and displayed in a time-ordered format, thus
the output result is friendly for review.

\subsubsection*{Printing in ftrace}

Printing is supported in ftrace.

In the kernel, \code{trace\_printk()} is used to output logs into the ftrace
ring buffer. Once you use it, you will find this API quite useful: logs saved
in ftrace buffer will not be bothered by console's long latency, and by
enlarging buffer size, you will have sufficient capacity to store extensive
logs. These logs will not flood the console immediately, you can extract logs
into file whenever you want to parse them.

A sysfs node called \code{trace\_marker} that allows the user space to place
logs into ftrace buffer. Through this interface, user space events and kernel
events can be synchronized together, thus developers can understand a flow
spanning the two spaces. The kernel documentation
\code{Documentation/trace/ftrace.rst} gives an example for how to write a log
into the \code{trace\_marker} node in C code. The code below is slightly
tweaked for easier calling.

\begin{lstlisting}
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

static void trace_write(const char *fmt, ...)
{
        va_list ap;
        char buf[256];
        int trace_fd, n;

        trace_fd = open("/sys/kernel/debug/tracing/trace_marker",
                          O_WRONLY);
        if (trace_fd < 0)
                return;

        va_start(ap, fmt);
        n = vsnprintf(buf, 256, fmt, ap);
        va_end(ap);

        write(trace_fd, buf, n);
}
\end{lstlisting}

A typical use case for \code{trace\_marker} is found in
\href{https://perfetto.dev/docs/data-sources/atrace}{ATrace}, which is a
part of Google's \href{https://ui.perfetto.dev/}{Perfetto} tool. Perfetto
is widely used for profiling Android UI performance and depends on the
ATrace to trace application events - the \code{trace\_marker} is the
underlying mechanism for tracing. While this article will remain on
basic tools, it will not dive into ATrace's details.

\subsubsection*{Debugging perf with ftrace}

Now it's a good time point for us to apply ftrace for debugging.

The following experiment is to inspect how the AUX buffer is consumed in perf.
The AUX buffer is a ring buffer designed to store hardware trace data from
components such as Arm CoreSight, Intel PT, etc.

After the trace data has been filled by a hardware IP, the kernel calls the
\code{perf\_aux\_output\_end()} function to update the head of the buffer and
send a notification to user space.

In the code piece below, the buffer supports two modes: overwrite mode and
normal mode. The overwrite mode is used for snapshots. For simplicity in
explanation, we solely focus on the normal mode from line 493 to line 498.
Line 496 saves the old head value into the \code{aux\_head} variable; in line
497, \code{rb->aux\_head} is updated as a new head by adding the \code{size}
to the old head.

We add tracing code in lines 500 and 501 to print the old head, the new head
and the size into ftrace.

\begin{lstlisting}
481 void perf_aux_output_end(struct perf_output_handle *handle, unsigned long size)
482 {
483         bool wakeup = !!(handle->aux_flags & PERF_AUX_FLAG_TRUNCATED);
484         struct perf_buffer *rb = handle->rb;
485         unsigned long aux_head;
486 
487         /* in overwrite mode, driver provides aux_head via handle */
488         if (rb->aux_overwrite) {
489                 handle->aux_flags |= PERF_AUX_FLAG_OVERWRITE;
490 
491                 aux_head = handle->head;
492                 rb->aux_head = aux_head;
493         } else {
494                 handle->aux_flags &= ~PERF_AUX_FLAG_OVERWRITE;
495 
496                 aux_head = rb->aux_head;
497                 rb->aux_head += size;
498         }
499 
500         trace_printk("old_head=0x%lx new_head=0x%lx size=0x%lx\n",
501                      aux_head, rb->aux_head, size);
            ...
535 }
\end{lstlisting}

The perf tool in user space calls \code{auxtrace\_mmap\_\_read\_head()} to
retrieve the latest head of the buffer. As shown from lines 1869 to 1875 in
the below code, it handles the overflow case by using a mask or dividing by
the buffer length. Finally, a delta between the old head and the new head is
calculated, taking into account any wrapping around, which is accomplished
between line 1877 and line 1880.

It already contains debugging code at line 1866 for printing logs, but it
only outputs messages to a terminal or a log file, we have no chance to print
them with kernel logs together.  This is why the \code{trace\_write()}
function at line 1882 is added to write logs into the ftrace buffer via the
\code{trace\_maker} interface.

\begin{lstlisting}
1844 static int __auxtrace_mmap__read(struct mmap *map,
1845                                  struct auxtrace_record *itr,
1846                                  struct perf_tool *tool, process_auxtrace_t fn,
1847                                  bool snapshot, size_t snapshot_size)
1848 {
1849         struct auxtrace_mmap *mm = &map->auxtrace_mmap;
1850         u64 head, old = mm->prev, offset, ref;
1851         unsigned char *data = mm->base;
1852         size_t size, head_off, old_off, len1, len2, padding;
1853         union perf_event ev;
1854         void *data1, *data2;
1855         int kernel_is_64_bit = perf_env__kernel_is_64_bit(evsel__env(NULL));
1856
1857         head = auxtrace_mmap__read_head(mm, kernel_is_64_bit);
1858
1859         if (snapshot &&
1860             auxtrace_record__find_snapshot(itr, mm->idx, mm, data, &head, &old))
1861                 return -1;
1862
1863         if (old == head)
1864                 return 0;
1865
1866         pr_debug3("auxtrace idx %d old %#"PRIx64" head %#"PRIx64" diff %#"PRIx64"\n",
1867                   mm->idx, old, head, head - old);
1868
1869         if (mm->mask) {
1870                 head_off = head & mm->mask;
1871                 old_off = old & mm->mask;
1872         } else {
1873                 head_off = head % mm->len;
1874                 old_off = old % mm->len;
1875         }
1876
1877         if (head_off > old_off)
1878                 size = head_off - old_off;
1879         else
1880                 size = mm->len - (old_off - head_off);
1881
1882         trace_write("%s: old_offset=0x%lx head_offset=0x%lx size=0x%lx\n",
1883                     __func__, old_off, head_off, size);
            ...
1957 }
\end{lstlisting}

Rebuild the Linux kernel and perf with the added printing code, reboot the
system, then it will be ready for debugging.

To prepare a fresh context for ftrace before running the test, you can use
several commands:

\begin{lstlisting}[
  	language=sh,
	breaklines=true
]
# Stop tracing
echo 0 > /sys/kernel/debug/tracing/tracing_on

# Cleanup ftrace data
echo > /sys/kernel/debug/tracing/trace

# Start tracing
echo 1 > /sys/kernel/debug/tracing/tracing_on
\end{lstlisting}

Then, run the test and stop tracing:

\begin{lstlisting}
# Run test
perf record -e cs_etm// -- ls

# Stop tracing
echo 0 > /sys/kernel/debug/tracing/tracing_on
\end{lstlisting}

At last, you can dump tracing log:

\begin{lstlisting}[
  	language=sh,
	breaklines=true
]
# Dump tracing data
cat /sys/kernel/debug/tracing/trace

# tracer: nop
#
# entries-in-buffer/entries-written: 7/7   #P:6
#
#                                _-----=> irqs-off/BH-disabled
#                               / _----=> need-resched
#                              | / _---=> hardirq/softirq
#                              || / _--=> preempt-depth
#                              ||| / _-=> migrate-disable
#                              |||| /     delay
#           TASK-PID     CPU#  |||||  TIMESTAMP  FUNCTION
#              | |         |   |||||     |         |
              ls-2041    [003] d..3.   220.497444: perf_aux_output_end: old_head=0x0 new_head=0xe26a0 size=0xe26a0
              ls-2041    [003] d..3.   220.498274: perf_aux_output_end: old_head=0xe26a0 new_head=0xf0da0 size=0xe700
              ls-2041    [003] d..3.   220.500091: perf_aux_output_end: old_head=0xf0da0 new_head=0xf61a0 size=0x5400
              ls-2041    [003] d..3.   220.500743: perf_aux_output_end: old_head=0xf61a0 new_head=0x108080 size=0x11ee0
              ls-2041    [003] d..3.   220.502813: perf_aux_output_end: old_head=0x108080 new_head=0x119dd0 size=0x11d50
              ls-2041    [003] d..1.   220.508788: perf_aux_output_end: old_head=0x119dd0 new_head=0x1d5310 size=0xbb540
            perf-2040    [002] .....   220.508985: tracing_mark_write: __auxtrace_mmap__read: old_offset=0x0 head_offset=0x1d5310 size=0x1d5310
\end{lstlisting}

The logs show that the \code{perf\_aux\_output\_end()} function has been
invoked multiple times in the kernel. The perf tool called
\code{\_\_auxtrace\_mmap\_\_read()} once to read out all trace data from the AUX
buffer. The writing to the AUX buffer in the kernel and the reading in user
space are not paired. It's apparent that the perf tool is not necessarily woken
up every time the kernel stores trace data. Nevertheless, we still don't
know the scheduling within this flow, which will be discussed soon.

\subsubsection*{Tracepoints in ftrace}

The naming 'ftrace' is derived from 'function trace', users can enable
function tracer or function graph tracer for function-based tracing. Over time,
ftrace has extended to support latency tracer for profiling scheduling latency.
In the log above, \code{"tracer:\ nop"} indicates that no tracer is enabled.

Furthermore, ftrace provides tracepoints which are predefined and invoked in
the kernel. These are commonly known as "static tracepoints". After
the system boots up, you can see the available tracepoints in the subfolder
\code{events} under the ftrace's debugfs folder.

More importantly, ftrace can combine printing, tracers, and tracepoints
together for debugging. The previous section was absent to show how the perf
tool is waken up in the test, the scheduler tracepoints can help us to easily
understand scheduling behaviours. By enabling the tracepoints, we get logs:

\begin{lstlisting}[
  	language=sh,
	breaklines=true
]
# Enable scheduler tracepoints
echo 1 > /sys/kernel/debug/tracing/events/sched/enable

# Run test
perf record -e cs_etm// -- ls

# Stop tracing
echo 0 > /sys/kernel/debug/tracing/tracing_on

# Dump tracing data
cat /sys/kernel/debug/tracing/trace

#                                _-----=> irqs-off/BH-disabled
#                               / _----=> need-resched
#                              | / _---=> hardirq/softirq
#                              || / _--=> preempt-depth
#                              ||| / _-=> migrate-disable
#                              |||| /     delay
#           TASK-PID     CPU#  |||||  TIMESTAMP  FUNCTION
#              | |         |   |||||     |         |
...
              ls-2660    [003] d..1.  4755.179918: perf_aux_output_end: old_head=0x11c460 new_head=0x21d7a0 size=0x101340
              ls-2660    [003] d.h4.  4755.179979: sched_waking: comm=perf pid=2659 prio=120 target_cpu=001
          <idle>-0       [001] dNh2.  4755.179998: sched_wakeup: comm=perf pid=2659 prio=120 target_cpu=001
          <idle>-0       [001] d..2.  4755.180002: sched_switch: prev_comm=swapper/1 prev_pid=0 prev_prio=120 prev_state=R ==> next_comm=perf next_pid=2659 next_prio=120
              ls-2660    [003] d.h2.  4755.180014: sched_stat_runtime: comm=ls pid=2660 runtime=4493620 [ns]
            perf-2659    [001] .....  4755.180089: tracing_mark_write: __auxtrace_mmap__read: old_offset=0x0 head_offset=0x21d7a0 size=0x21d7a0
\end{lstlisting}

The logs show that the profiled program \(ls\) stored hardware tracing data
into AUX buffer. Then it woke up the perf tool in the \code{sched\_waking}
event. Afterwards, the \(CPU1\) was pulled out from idle, and the scheduler
placed the perf to run on it. We can know that the \(ls\) program and the
perf running on two different CPUs, so that avoid performance degradation
due to parallel execution during profiling.

In this section, the printing and static tracepoints in ftrace have shown
their power. However, they are not efficient, as we must rebuild the source
code to add tracing. We will explore dynamic tracing to add tracepoints on the
fly.

\section*{Dynamic tracing}

If you have experience with debugger, an often used feature is breakpoint. You
select a code line, set a breakpoint, and then kick off the program to run.
When the program reaches the breakpoint, it halts, and the debugger takes
over control. At this point, since the program is stopped, you can take your
time to read variables, review memory content, and dump CPU general registers.

A subtle aspect of a breakpoint is it can be set as either a hardware
breakpoint or a software breakpoint. A hardware breakpoint is to set an
address in the CPU's debug register, while a software breakpoint uses the
break instruction (the Arm instruction is \code{BRK}) to replace an
original instruction at the specified address. Both methods ultimately
interrupt the program execution and transfer control to the debugger for
further inspection.

We can take dynamic tracing as a self-hosted debugger, often referred to as
\(probe\) in Linux. When we add a probe, a break instruction is injected into
a specified address, and an event is attached to it for accessing additional
data. The original instruction is copied to somewhere for single-step
execution.

Ftrace provides \(kprobe\) and \(uprobe\) for adding probe in the kernel and
user space respectively. We will see demonstrations of how to use them.

\subsubsection*{Adding probe in the kernel}

The kprobe provides the sysfs node \code{kprobe\_events} under the
ftrace's umbrella for adding dynamic tracepoints.

Adding a probe requires specifying two things: the probed address and the
inspected data. The file \code{Documentation/trace/kprobetrace.rst}
in the kernel tree explains the kprobe syntax.

An obstacle for using kprobe is figuring out an appropriate address and
mapping the interested variables to where they are stored. For example, it's
not difficult to trace a function's entry or return, but it would not be
straightforward to decide which address should be traced if intending to
observe in the middle of the function. Arguments or local variables might be
stored in general registers or in the stack, and it's possible that a
variable is located in the heap.

Therefore, to lower the barrier for applying kprobe, we need to understand how
a Linux kernel image is compiled. We can disassemble a kernel ELF file with the
\code{objdump} command. If you are working on a cross compilation environment
for Arm64, use the command \code{aarch64-linux-gnu-objdump} instead. The
command below uses two options for the disassembly: the option \code{-d} is
for displaying assembler, and the option \code{-S} is for intermixing the
source code with disassembly so we can connect C code with assembly
instructions.

\begin{lstlisting}[
  	language=sh,
	breaklines=true
]
aarch64-linux-gnu-objdump -S -d vmlinux > kernel.objdump
\end{lstlisting}

In addition to the knowledge of assembly language, understanding the
general-purpose register usage in the procedure call is crucial for reading
disassembly. The documentation
\href{https://github.com/ARM-software/abi-aa/releases/download/2023Q3/aapcs64.pdf}{AAPCS64}
defines the Procedure Call Standard for AArch64. Applying the mentioned
knowledges, let’s take a closer look at the disassmebly of the
\code{perf\_aux\_output\_end()} function.

\begin{lstlisting}[
	breaklines=true
]
ffff8000802a0ee0 <perf_aux_output_end>:
ffff8000802a0ee0:	d503201f 	nop
ffff8000802a0ee4:	d503201f 	nop
{
ffff8000802a0ee8:	d503233f 	paciasp
ffff8000802a0eec:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
ffff8000802a0ef0:	aa0103e2 	mov	x2, x1
ffff8000802a0ef4:	910003fd 	mov	x29, sp
ffff8000802a0ef8:	a90153f3 	stp	x19, x20, [sp, #16]
ffff8000802a0efc:	aa0003f3 	mov	x19, x0
ffff8000802a0f00:	f90013f5 	str	x21, [sp, #32]
	struct perf_buffer *rb = handle->rb;
ffff8000802a0f04:	f9400414 	ldr	x20, [x0, #8]
	bool wakeup = !!(handle->aux_flags & PERF_AUX_FLAG_TRUNCATED);
ffff8000802a0f08:	f9401000 	ldr	x0, [x0, #32]
	if (rb->aux_overwrite) {
ffff8000802a0f0c:	b940b681 	ldr	w1, [x20, #180]
	bool wakeup = !!(handle->aux_flags & PERF_AUX_FLAG_TRUNCATED);
ffff8000802a0f10:	12000015 	and	w21, w0, #0x1
	if (rb->aux_overwrite) {
ffff8000802a0f14:	34000741 	cbz	w1, ffff8000802a0ffc <perf_aux_output_end+0x11c>
		aux_head = handle->head;
ffff8000802a0f18:	f9401661 	ldr	x1, [x19, #40]
		handle->aux_flags |= PERF_AUX_FLAG_OVERWRITE;
ffff8000802a0f1c:	b27f0000 	orr	x0, x0, #0x2
ffff8000802a0f20:	f9001260 	str	x0, [x19, #32]
		rb->aux_head = aux_head;
ffff8000802a0f24:	aa0103e0 	mov	x0, x1
ffff8000802a0f28:	f9004a80 	str	x0, [x20, #144]

...

		handle->aux_flags &= ~PERF_AUX_FLAG_OVERWRITE;
ffff8000802a0ffc:	927ef800 	and	x0, x0, #0xfffffffffffffffd
ffff8000802a1000:	f9001260 	str	x0, [x19, #32]
		aux_head = rb->aux_head;
ffff8000802a1004:	f9404a81 	ldr	x1, [x20, #144]
		rb->aux_head += size;
ffff8000802a1008:	8b020020 	add	x0, x1, x2
ffff8000802a100c:	17ffffc7 	b	ffff8000802a0f28 <perf_aux_output_end+0x48>
ffff8000802a1010:	d503201f 	nop
ffff8000802a1014:	d503201f 	nop

ffff8000802a1018 <rb_alloc>:
ffff8000802a1018:	d503201f 	nop
ffff8000802a101c:	d503201f 	nop
	page->mapping = NULL;
	__free_page(page);
}
\end{lstlisting}

As defined in AAPCS64, the registers \code{x0} - \code{x7} are used to pass
function arguments. \code{perf\_aux\_output\_end()} has two arguments: the
first one is an output handler, and the second one is the filled buffer
size. When it is called, the registers \code{x0} and \code{x1} hold values for
these two arguments, respectively. At the address \code{0xffff8000802a0ef0},
the instruction is \code{"move x2, x1"}, which moves the register \code{x1}'s
value into \code{x2}. Later in the function, the register \code{x2} holds the
value for the \code{size} while \code{x1} is assigned to intermediate values.

The register \code{x20} contains a pointer value pointing to structure
\code{perf\_buffer}, it is assigned at \code{0xffff8000802a0f04}. Then, at
\code{0xffff8000802a0f0c} the field \code{rb->aux\_overwrite} is loaded:
since the flag has an offset of \code{180} in the structure, the instruction
\code{"ldr w1, [x20, \#180]"} loads it into the register \code{w1}
(using \code{w1} as target register means loading value into the \code{x1}
with upper 4 bytes zeroed).

At \code{0xffff8000802a0f14}, the instruction \code{"cbz w1, ffff8000802a0ffc"}
compares the buffer mode. Now we are only interesed in the normal mode and
\code{w1} is zero, as a result, the instruction  will jump to
\code{0xffff8000802a0ffc}.

From there, it sets the \code{handle->aux\_flags} and retrieves the old buffer
head into the register \code{x1} at \code{0xffff8000802a1004} - the
instruction is \code{"ldr x1, [x20, \#144]"}, \code{x20} is the pointer
for the structure \code{perf\_buffer}, and \code{144} is the offset of the
buffer's head in the structure. As we know, \code{x2} contains the written
buffer size, and it is added to the old buffer head (\code{x1}) for a new
buffer head stored into the register \code{x0}. This is accomplished
at \code{0xffff8000802a1008}.

The sequential address \code{0xffff8000802a100c} would be a good trace point,
with reading \code{x0} for the new head, \code{x1} for the old head, and
\code{x2} for the filled data size. We can add a probe with the command:

\begin{lstlisting}[
  	language=sh,
	breaklines=true
]
cd /sys/kernel/debug/tracing/
echo 'p:myprobe 0xffff8000802a100c new_head=%x0:x64 old_head=%x1:x64 size=%x2:x64' \
       > kprobe_events
\end{lstlisting}

We can use the 'function name + offset' format to replace the arbitrary
address for specifying a probe address. This is more readable and avoids
concerns about address alterations caused by a rebuild:

\begin{lstlisting}[
  	language=sh,
	breaklines=true
]
echo 'p:myprobe perf_aux_output_end+0x12c new_head=%x0:x64 \
       old_head=%x1:x64 size=%x2:x64' > kprobe_events
\end{lstlisting}

Moreover, the probe supports syntax for fetching memory with the fetch
register with an offset (the offset can be plus \code{+} or minus \code{-}).
In above case, the old head is loaded into \code{x1} from the address pointed
by \code{x20} plus \code{144}. Rather than accessing the register
\code{x1}, we can use \code{'+144(\%x20)'} for retrieving the old head.
Therefore, the probe command can be updated as:

\begin{lstlisting}[
  	language=sh,
	breaklines=true
]
echo 'p:myprobe perf_aux_output_end+0x12c new_head=%x0:x64 \
       old_head=+144(%x20):x64 size=%x2:x64' > kprobe_events
\end{lstlisting}

\subsubsection*{Adding probe in user space}

\begin{lstlisting}[
  	language=sh,
	breaklines=true
]
cd /sys/kernel/debug/tracing/
echo 'p:myprobe 0xffff8000802a100c new_head=%x0:x64 \
       old_head=%x1:x64 size=%x2:x64' > kprobe_events
echo 'p:myprobe perf_aux_output_end+0x12c new_head=%x0:x64 \
       old_head=%x1:x64 size=%x2:x64' > kprobe_events
echo 'p:myprobe perf_aux_output_end+0x12c new_head=%x0:x64 \
       old_head=+144(%x20):x64 size=%x2:x64' > kprobe_events

echo 1 > events/kprobes/myprobe1/enable

echo 'p /mnt/linux-kernel/linux-cs-dev/tools/perf/perf:0x2079e0 old_off=+128(%sp):x64 head_off=+120(%sp):x64 size=+112(%sp):x64' > uprobe_events

echo 1 > events/uprobes/p_perf_0x2079e0/enable

cat trace
# tracer: nop
#
# entries-in-buffer/entries-written: 7/7   #P:6
#
#                                _-----=> irqs-off/BH-disabled
#                               / _----=> need-resched
#                              | / _---=> hardirq/softirq
#                              || / _--=> preempt-depth
#                              ||| / _-=> migrate-disable
#                              |||| /     delay
#           TASK-PID     CPU#  |||||  TIMESTAMP  FUNCTION
#              | |         |   |||||     |         |
              ls-3480    [005] d..3. 13312.444215: myprobe1: (perf_aux_output_end+0x12c/0x138) new_head=0xd71f0 old_head=0x0 size=0xd71f0
              ls-3480    [005] d..3. 13312.444779: myprobe1: (perf_aux_output_end+0x12c/0x138) new_head=0xe22a0 old_head=0xd71f0 size=0xb0b0
              ls-3480    [005] d..3. 13312.446907: myprobe1: (perf_aux_output_end+0x12c/0x138) new_head=0xf2950 old_head=0xe22a0 size=0x106b0
              ls-3480    [005] d..3. 13312.449854: myprobe1: (perf_aux_output_end+0x12c/0x138) new_head=0x10e470 old_head=0xf2950 size=0x1bb20
              ls-3480    [005] d..3. 13312.456476: myprobe1: (perf_aux_output_end+0x12c/0x138) new_head=0x1ac6e0 old_head=0x10e470 size=0x9e270
              ls-3480    [005] d..1. 13312.460459: myprobe1: (perf_aux_output_end+0x12c/0x138) new_head=0x243560 old_head=0x1ac6e0 size=0x96e80
            perf-3479    [002] DNZff 13312.460598: p_perf_0x2079e0: (0xaaaad0f979e0) old_off=0x0 head_off=0x243560 size=0x243560
\end{lstlisting}


\end{document}
